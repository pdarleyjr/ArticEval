
/**
@draggable/tooltip - https://github.com/Draggable/tooltip
Version: 1.2.1
Author: Draggable https://draggable.io
*/


!function(){"use strict";try{if("undefined"!=typeof document){var o=document.createElement("style");o.appendChild(document.createTextNode('._3x4ZIcu-{position:absolute;background:#1f2937;color:#fff;padding:.75rem;border-radius:.375rem;max-width:200px;z-index:50;visibility:hidden;opacity:0;transition:opacity .2s;pointer-events:none;left:0;top:0}._3x4ZIcu-.JIt36hCJ{visibility:visible;opacity:1;pointer-events:all}._3x4ZIcu-:before{content:"";position:absolute;width:0;height:0;border:6px solid transparent}._3x4ZIcu-[data-position=top]:before{border-top-color:#1f2937;bottom:-12px;left:50%;transform:translate(-50%)}._3x4ZIcu-[data-position=bottom]:before{border-bottom-color:#1f2937;top:-12px;left:50%;transform:translate(-50%)}._3x4ZIcu-[data-position=left]:before{border-left-color:#1f2937;right:-12px;top:50%;transform:translateY(-50%)}._3x4ZIcu-[data-position=right]:before{border-right-color:#1f2937;left:-12px;top:50%;transform:translateY(-50%)}._3x4ZIcu-[data-position=top-left]:before{border-top-color:#1f2937;bottom:-12px;left:12px;transform:none}._3x4ZIcu-[data-position=top-right]:before{border-top-color:#1f2937;bottom:-12px;right:12px;left:auto;transform:none}._3x4ZIcu-[data-position=bottom-left]:before{border-bottom-color:#1f2937;top:-12px;left:12px;transform:none}._3x4ZIcu-[data-position=bottom-right]:before{border-bottom-color:#1f2937;top:-12px;right:12px;left:auto;transform:none}')),document.head.appendChild(o)}}catch(t){console.error("vite-plugin-css-injected-by-js",t)}}();
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
const tooltip = "_3x4ZIcu-";
const visible = "JIt36hCJ";
const styles = {
  tooltip,
  visible
};
const defaultOptions = {
  triggerName: "tooltip"
};
class SmartTooltip {
  constructor(options = defaultOptions) {
    __publicField(this, "triggerName");
    __publicField(this, "tooltip");
    __publicField(this, "activeTriggerType", null);
    __publicField(this, "spacing", 12);
    __publicField(this, "handleClick", (e) => {
      const triggerName = this.triggerName;
      const trigger = e.target.closest(`[${triggerName}][${triggerName}-type="click"]`);
      if (trigger) {
        if (this.isVisible()) {
          this.hide();
        } else {
          const content = trigger.getAttribute(`${triggerName}`);
          this.show(trigger, content);
          this.activeTriggerType = "click";
        }
      } else {
        this.hide();
      }
    });
    __publicField(this, "handleMouseOver", (e) => {
      const triggerName = this.triggerName;
      const trigger = e.target.closest(`[${triggerName}]`);
      if (this.activeTriggerType !== "click" && (trigger == null ? void 0 : trigger.getAttribute(`${triggerName}-type`)) !== "click") {
        const content = trigger == null ? void 0 : trigger.getAttribute(`${triggerName}`);
        if (content) {
          this.show(trigger, content);
          this.activeTriggerType = "hover";
        }
      }
    });
    __publicField(this, "handleMouseOut", (e) => {
      const triggerName = this.triggerName;
      const trigger = e.target.closest(`[${triggerName}]`);
      if (this.activeTriggerType !== "click" && (trigger == null ? void 0 : trigger.getAttribute(`${triggerName}-type`)) !== "click") {
        this.hide();
      }
    });
    __publicField(this, "handleResize", () => {
      if (this.isVisible()) {
        this.hide();
      }
    });
    __publicField(this, "handleScroll", () => {
      if (this.isVisible()) {
        this.hide();
      }
    });
    this.triggerName = `data-${options.triggerName}`;
    this.tooltip = document.createElement("div");
    this.tooltip.className = `d-tooltip ${styles.tooltip}`;
    document.body.appendChild(this.tooltip);
    this.setupEventListeners();
  }
  setupEventListeners() {
    document.addEventListener("mouseover", this.handleMouseOver);
    document.addEventListener("mouseout", this.handleMouseOut);
    document.addEventListener("touchstart", this.handleMouseOver);
    document.addEventListener("touchend", this.handleMouseOut);
    document.addEventListener("click", this.handleClick);
    window.addEventListener("resize", this.handleResize);
    window.addEventListener("scroll", this.handleScroll, true);
  }
  isVisible() {
    return this.tooltip.classList.contains(styles.visible);
  }
  /**
   * Calculates the optimal position for the tooltip relative to the trigger element.
   * It tries to find a position where the tooltip fits within the viewport.
   * If no position fits, it defaults to the first position in the list.
   *
   * @param {HTMLElement} trigger - The HTML element that triggers the tooltip.
   * @returns {Position} The calculated position for the tooltip.
   */
  calculatePosition(trigger) {
    const triggerRect = trigger.getBoundingClientRect();
    const tooltipRect = this.tooltip.getBoundingClientRect();
    const positions = [
      {
        name: "top",
        x: triggerRect.left + (triggerRect.width - tooltipRect.width) / 2,
        y: triggerRect.top - tooltipRect.height - this.spacing
      },
      {
        name: "bottom",
        x: triggerRect.left + (triggerRect.width - tooltipRect.width) / 2,
        y: triggerRect.bottom + this.spacing
      },
      {
        name: "left",
        x: triggerRect.left - tooltipRect.width - this.spacing,
        y: triggerRect.top + (triggerRect.height - tooltipRect.height) / 2
      },
      {
        name: "right",
        x: triggerRect.right + this.spacing,
        y: triggerRect.top + (triggerRect.height - tooltipRect.height) / 2
      },
      // Corner positions
      {
        name: "top-left",
        x: triggerRect.left,
        y: triggerRect.top - tooltipRect.height - this.spacing
      },
      {
        name: "top-right",
        x: triggerRect.right - tooltipRect.width,
        y: triggerRect.top - tooltipRect.height - this.spacing
      },
      {
        name: "bottom-left",
        x: triggerRect.left,
        y: triggerRect.bottom + this.spacing
      },
      {
        name: "bottom-right",
        x: triggerRect.right - tooltipRect.width,
        y: triggerRect.bottom + this.spacing
      }
    ];
    return positions.find((pos) => this.fitsInViewport(pos, tooltipRect)) || positions[0];
  }
  /**
   * Checks if the tooltip fits within the viewport and is not obstructed by other elements.
   *
   * @param pos - The position of the tooltip.
   * @param tooltipRect - The bounding rectangle of the tooltip.
   * @returns `true` if the tooltip fits within the viewport and is not obstructed, otherwise `false`.
   */
  fitsInViewport(pos, tooltipRect) {
    const inViewport = pos.x >= 0 && pos.y >= 0 && pos.x + tooltipRect.width <= window.innerWidth && pos.y + tooltipRect.height <= window.innerHeight;
    if (!inViewport) return false;
    const points = [
      [pos.x, pos.y],
      // Top-left
      [pos.x + tooltipRect.width, pos.y],
      // Top-right
      [pos.x, pos.y + tooltipRect.height],
      // Bottom-left
      [pos.x + tooltipRect.width, pos.y + tooltipRect.height],
      // Bottom-right
      [pos.x + tooltipRect.width / 2, pos.y + tooltipRect.height / 2]
      // Center
    ];
    const elementsAtPoints = points.flatMap(([x, y]) => Array.from(document.elementsFromPoint(x, y)));
    const obstructingElements = elementsAtPoints.filter((element) => {
      if (this.tooltip.contains(element) || // Exclude tooltip and its children
      element === this.tooltip || element.classList.contains(styles.tooltip) || // Ignore other tooltips
      getComputedStyle(element).pointerEvents === "none") {
        return false;
      }
    });
    return obstructingElements.length === 0;
  }
  show(trigger, content) {
    this.tooltip.innerHTML = content ?? "";
    this.tooltip.classList.add(styles.visible);
    const position = this.calculatePosition(trigger);
    this.tooltip.style.left = `${position.x}px`;
    this.tooltip.style.top = `${position.y}px`;
    this.tooltip.dataset.position = position.name;
  }
  hide() {
    this.tooltip.classList.remove(styles.visible);
    this.activeTriggerType = null;
  }
  destroy() {
    document.removeEventListener("mouseover", this.handleMouseOver);
    document.removeEventListener("mouseout", this.handleMouseOut);
    document.removeEventListener("touchstart", this.handleMouseOver);
    document.removeEventListener("touchend", this.handleMouseOut);
    document.removeEventListener("click", this.handleClick);
    window.removeEventListener("resize", this.handleResize);
    window.removeEventListener("scroll", this.handleScroll, true);
    this.tooltip.remove();
  }
}
const Tooltip = SmartTooltip;
if (window !== void 0) {
  window.SmartTooltip = SmartTooltip;
}
export {
  SmartTooltip,
  Tooltip,
  SmartTooltip as default
};
